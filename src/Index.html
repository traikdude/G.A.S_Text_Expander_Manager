<!DOCTYPE html>
<html>

<head>
  <base target="_top">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Expansion Manager</title>
  <style>
    /* ========================================================================
       GLOBAL STYLES
       ======================================================================== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      color: #202124;
      background: #f8f9fa;
      padding: 16px;
      overflow-x: hidden;
    }

    /* ========================================================================
       HEADER
       ======================================================================== */
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .header h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .header-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 13px;
      opacity: 0.95;
    }

    .user-email {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .user-email::before {
      content: 'üë§';
      font-size: 16px;
    }

    .version-badge {
      background: rgba(255, 255, 255, 0.2);
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }

    /* ========================================================================
       STATUS BAR
       ======================================================================== */
    .status-bar {
      background: white;
      padding: 12px 20px;
      border-radius: 6px;
      margin-bottom: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      flex-wrap: wrap;
      gap: 12px;
    }

    .status-text {
      font-size: 13px;
      color: #5f6368;
      font-weight: 500;
    }

    .status-text.loading {
      color: #1a73e8;
    }

    .status-text.error {
      color: #d93025;
    }

    .status-text.success {
      color: #1e8e3e;
    }

    .action-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* ========================================================================
       BUTTONS
       ======================================================================== */
    button {
      background: #1a73e8;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      outline: none;
    }

    button:hover {
      background: #1557b0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      background: #dadce0;
      color: #80868b;
      cursor: not-allowed;
      box-shadow: none;
    }

    button.btn-secondary {
      background: #5f6368;
    }

    button.btn-secondary:hover {
      background: #3c4043;
    }

    button.btn-danger {
      background: #d93025;
    }

    button.btn-danger:hover {
      background: #a50e0e;
    }

    button.btn-success {
      background: #1e8e3e;
    }

    button.btn-success:hover {
      background: #137333;
    }

    button.btn-small {
      padding: 6px 12px;
      font-size: 12px;
    }

    /* ========================================================================
       TABS
       ======================================================================== */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      background: white;
      padding: 4px;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .tab {
      flex: 1;
      padding: 10px 16px;
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: #5f6368;
      transition: all 0.2s;
    }

    .tab:hover {
      background: #f1f3f4;
      color: #202124;
    }

    .tab.active {
      background: #1a73e8;
      color: white;
      box-shadow: 0 1px 3px rgba(26, 115, 232, 0.3);
    }

    /* ========================================================================
       TAB CONTENT
       ======================================================================== */
    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* ========================================================================
       SEARCH & FILTER
       ======================================================================== */
    .search-filter {
      background: white;
      padding: 16px;
      border-radius: 6px;
      margin-bottom: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .search-box {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .search-input {
      flex: 1;
      padding: 10px 12px;
      border: 1px solid #dadce0;
      border-radius: 4px;
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s;
    }

    .search-input:focus {
      border-color: #1a73e8;
      box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.1);
    }

    .filter-chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .chip {
      padding: 6px 12px;
      background: #e8f0fe;
      color: #1a73e8;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }

    .chip:hover {
      background: #d2e3fc;
    }

    .chip.active {
      background: #1a73e8;
      color: white;
    }

    /* Language-specific chip colors */
    .chip.lang-spanish {
      background: #fce8e6;
      color: #d93025;
    }

    .chip.lang-spanish:hover {
      background: #f8d7d4;
    }

    .chip.lang-spanish.active {
      background: #d93025;
      color: white;
    }

    .chip.lang-english {
      background: #e6f4ea;
      color: #137333;
    }

    .chip.lang-english:hover {
      background: #ceead6;
    }

    .chip.lang-english.active {
      background: #137333;
      color: white;
    }

    /* Filter result count banner */
    .filter-result-count {
      padding: 10px 14px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e8f0fe 100%);
      border-radius: 8px;
      font-size: 13px;
      color: #5f6368;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid #dadce0;
    }

    .filter-result-count .count {
      color: #1a73e8;
      font-weight: 600;
    }

    .filter-result-count .clear-filters-btn {
      margin-left: auto;
      padding: 4px 10px;
      font-size: 12px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .filter-result-count .clear-filters-btn:hover {
      background: #f1f3f4;
      border-color: #1a73e8;
      color: #1a73e8;
    }

    /* Filter section label */
    .filter-label {
      font-size: 12px;
      color: #5f6368;
      font-weight: 500;
      margin-right: 8px;
    }

    /* ========================================================================
       SHORTCUTS GRID
       ======================================================================== */
    .shortcuts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }

    .shortcut-card {
      background: white;
      border: 1px solid #dadce0;
      border-radius: 8px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
    }

    .shortcut-card:hover {
      border-color: #1a73e8;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      transform: translateY(-2px);
    }

    .shortcut-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .shortcut-key {
      font-size: 16px;
      font-weight: 600;
      color: #202124;
      word-break: break-word;
      flex: 1;
      margin-right: 8px;
    }

    .shortcut-actions {
      display: flex;
      gap: 4px;
    }

    .icon-btn {
      background: transparent;
      color: #5f6368;
      padding: 6px;
      border-radius: 50%;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }

    .icon-btn:hover {
      background: #f1f3f4;
      color: #202124;
      transform: none;
    }

    .icon-btn.favorite {
      color: #5f6368;
    }

    .icon-btn.favorite.active {
      color: #fbbc04;
    }

    .icon-btn.favorite:hover {
      color: #fbbc04;
    }

    .shortcut-expansion {
      color: #5f6368;
      font-size: 13px;
      margin-bottom: 12px;
      max-height: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .shortcut-meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    .meta-tag {
      padding: 4px 8px;
      background: #f1f3f4;
      color: #5f6368;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
    }

    .meta-tag.app {
      background: #e8f0fe;
      color: #1a73e8;
    }

    .meta-tag.lang {
      background: #fce8e6;
      color: #c5221f;
    }

    /* ========================================================================
       EMPTY STATE
       ======================================================================== */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #5f6368;
    }

    .empty-state-icon {
      font-size: 64px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .empty-state h3 {
      font-size: 18px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #202124;
    }

    .empty-state p {
      font-size: 14px;
      margin-bottom: 20px;
    }

    /* ========================================================================
       MODAL
       ======================================================================== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-y: auto;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: white;
      border-radius: 8px;
      width: 100%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      animation: modalSlideIn 0.3s ease-out;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modal-header {
      padding: 20px;
      border-bottom: 1px solid #e8eaed;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      font-size: 20px;
      font-weight: 600;
      color: #202124;
    }

    .modal-close {
      background: transparent;
      color: #5f6368;
      font-size: 24px;
      cursor: pointer;
      padding: 4px;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-close:hover {
      background: #f1f3f4;
      color: #202124;
    }

    .modal-body {
      padding: 20px;
    }

    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #e8eaed;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    /* ========================================================================
       FORM
       ======================================================================== */
    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-weight: 500;
      margin-bottom: 6px;
      color: #202124;
      font-size: 13px;
    }

    .form-label.required::after {
      content: ' *';
      color: #d93025;
    }

    .form-input,
    .form-textarea,
    .form-select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #dadce0;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s;
    }

    .form-input:focus,
    .form-textarea:focus,
    .form-select:focus {
      border-color: #1a73e8;
      box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.1);
    }

    .form-textarea {
      resize: vertical;
      min-height: 100px;
      font-family: 'Courier New', monospace;
    }

    .form-help {
      font-size: 12px;
      color: #5f6368;
      margin-top: 4px;
    }

    .form-help.error {
      color: #d93025;
    }

    /* ========================================================================
       IMPORT SECTION
       ======================================================================== */
    .import-section {
      background: white;
      border-radius: 6px;
      padding: 20px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .import-mode-selector {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
    }

    .mode-option {
      flex: 1;
      padding: 16px;
      border: 2px solid #dadce0;
      border-radius: 6px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
    }

    .mode-option:hover {
      border-color: #1a73e8;
      background: #f8f9fa;
    }

    .mode-option.active {
      border-color: #1a73e8;
      background: #e8f0fe;
    }

    .mode-option-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
      color: #202124;
    }

    .mode-option-desc {
      font-size: 12px;
      color: #5f6368;
    }

    .import-textarea {
      width: 100%;
      min-height: 200px;
      padding: 12px;
      border: 1px solid #dadce0;
      border-radius: 4px;
      font-size: 13px;
      font-family: 'Courier New', monospace;
      resize: vertical;
      outline: none;
      margin-bottom: 16px;
    }

    .import-textarea:focus {
      border-color: #1a73e8;
      box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.1);
    }

    .import-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .import-result {
      margin-top: 16px;
      padding: 12px;
      border-radius: 4px;
      font-size: 13px;
      display: none;
    }

    .import-result.success {
      display: block;
      background: #e6f4ea;
      color: #137333;
      border: 1px solid #1e8e3e;
    }

    .import-result.error {
      display: block;
      background: #fce8e6;
      color: #a50e0e;
      border: 1px solid #d93025;
    }

    /* ========================================================================
       TOAST NOTIFICATIONS
       ======================================================================== */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 400px;
    }

    .toast {
      background: white;
      padding: 12px 16px;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 12px;
      animation: toastSlideIn 0.3s ease-out;
      border-left: 4px solid #1a73e8;
    }

    @keyframes toastSlideIn {
      from {
        opacity: 0;
        transform: translateX(100%);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .toast.good {
      border-left-color: #1e8e3e;
    }

    .toast.warn {
      border-left-color: #fbbc04;
    }

    .toast.bad {
      border-left-color: #d93025;
    }

    .toast-icon {
      font-size: 20px;
    }

    .toast-message {
      flex: 1;
      font-size: 13px;
      color: #202124;
    }

    /* ========================================================================
       LOADING SPINNER
       ======================================================================== */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* ========================================================================
       RESPONSIVE DESIGN
       ======================================================================== */
    @media (max-width: 768px) {
      body {
        padding: 8px;
      }

      .header {
        padding: 16px;
      }

      .header h1 {
        font-size: 20px;
      }

      .shortcuts-grid {
        grid-template-columns: 1fr;
      }

      .import-options {
        grid-template-columns: 1fr;
      }

      .toast-container {
        left: 10px;
        right: 10px;
        max-width: none;
      }
    }

    /* ========================================================================
       UTILITY CLASSES
       ======================================================================== */
    .hidden {
      display: none !important;
    }

    .text-center {
      text-align: center;
    }

    .mb-0 {
      margin-bottom: 0 !important;
    }

    .mb-1 {
      margin-bottom: 8px !important;
    }

    .mb-2 {
      margin-bottom: 16px !important;
    }

    .mb-3 {
      margin-bottom: 24px !important;
    }

    .mt-0 {
      margin-top: 0 !important;
    }

    .mt-1 {
      margin-top: 8px !important;
    }

    .mt-2 {
      margin-top: 16px !important;
    }

    .mt-3 {
      margin-top: 24px !important;
    }

    /* * üêõ FIX FOR FROZEN FIRST ITEM
     * The fixed header (search bar/tabs) was covering the top of the list.
     * We add padding to the top of the scroll container to push the content down.
     */
    .top-bar {
      z-index: 1000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #f8f9fa;
      padding: 16px 16px 0 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .main-content {
      padding-top: calc(var(--topbar-h, 220px) + 12px) !important;
      padding-bottom: 50px;
    }

    /* Adjust margins for fixed header components */
    .top-bar .header {
      margin-bottom: 12px;
    }

    .top-bar .status-bar {
      margin-bottom: 12px;
    }

    .top-bar .tabs {
      margin-bottom: 0;
    }
  </style>
</head>

<body>
  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <div class="top-bar">
    <!-- Header -->
    <div class="header">
      <h1>üìù Text Expansion Manager</h1>
      <div class="header-info">
        <div class="user-email" id="userEmail">Loading...</div>
        <div class="version-badge" id="versionBadge">v1.0</div>
      </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-text" id="statusText">Loading application...</div>
      <div class="action-buttons">
        <button id="btnRefresh" onclick="refreshData(true)">
          üîÑ Refresh
        </button>
        <button id="btnNew" onclick="openNewShortcutModal()">
          ‚ûï New / Edit
        </button>
      </div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab active" id="tabAll" onclick="switchTab('all')">
        üìã All Shortcuts
      </button>
      <button class="tab" id="tabFav" onclick="switchTab('fav')">
        ‚≠ê My Favorites
      </button>
      <button class="tab" id="tabImport" onclick="switchTab('import')">
        üì• Import
      </button>
    </div>
  </div>

  <div class="main-content">
    <!-- Tab Content: All Shortcuts -->
    <div class="tab-content active" id="contentAll">
      <!-- Search & Filter -->
      <div class="search-filter">
        <div class="search-box">
          <input type="text" class="search-input" id="searchInput"
            placeholder="üîç Search shortcuts by name, content, tags, or language...">
          <button id="btnClearSearch">Clear</button>
        </div>

        <!-- Filter Result Count Banner (hidden by default) -->
        <div class="filter-result-count" id="filterResultCount" style="display: none;">
          <span>üîé</span>
          <span>Showing <span class="count" id="filteredCount">0</span> of <span id="totalCount">0</span> results</span>
          <button class="clear-filters-btn" id="btnClearAllFilters">Clear All Filters</button>
        </div>

        <!-- Category Filter Chips -->
        <div class="filter-chips" id="categoryFilters">
          <span class="filter-label">Category:</span>
          <div class="chip active" data-filter="all" data-filter-type="category">üìã All</div>
          <div class="chip" data-filter="favorites" data-filter-type="category">‚≠ê Favorites</div>
        </div>

        <!-- Language Filter Chips -->
        <div class="filter-chips" id="languageFilters" style="margin-top: 8px;">
          <span class="filter-label">Language:</span>
          <div class="chip active" data-filter="all" data-filter-type="language">üåê All</div>
          <div class="chip lang-spanish" data-filter="spanish" data-filter-type="language">üá™üá∏ Spanish</div>
          <div class="chip lang-english" data-filter="english" data-filter-type="language">üá∫üá∏ English</div>
        </div>

        <!-- Type/Category Filter Chips (based on description field) -->
        <div class="filter-chips" id="typeFilters" style="margin-top: 8px;">
          <span class="filter-label">Type:</span>
          <div class="chip active" data-filter="all" data-filter-type="type">üìÅ All</div>
          <div class="chip" data-filter="dates" data-filter-type="type">üìÖ Dates</div>
          <div class="chip" data-filter="numbers" data-filter-type="type">üî¢ Numbers</div>
          <div class="chip" data-filter="greetings" data-filter-type="type">üëã Greetings</div>
          <div class="chip" data-filter="symbols" data-filter-type="type">‚ú® Symbols</div>
          <div class="chip" data-filter="kaomoji" data-filter-type="type">üòä Kaomoji</div>
          <div class="chip" data-filter="email" data-filter-type="type">üìß Email</div>
          <div class="chip" data-filter="zodiac" data-filter-type="type">‚ôà Zodiac</div>
        </div>
      </div>

      <!-- Shortcuts Grid -->
      <div class="shortcuts-grid" id="shortcutsGrid">
        <!-- Cards will be dynamically inserted here -->
      </div>

      <!-- Empty State -->
      <div class="empty-state hidden" id="emptyStateAll">
        <div class="empty-state-icon">üìù</div>
        <h3>No shortcuts yet</h3>
        <p>Create your first text expansion shortcut to get started!</p>
        <button onclick="openNewShortcutModal()">‚ûï Create First Shortcut</button>
      </div>
    </div>

    <!-- Tab Content: Favorites -->
    <div class="tab-content" id="contentFav">
      <div class="shortcuts-grid" id="favoritesGrid">
        <!-- Favorite cards will be dynamically inserted here -->
      </div>

      <div class="empty-state hidden" id="emptyStateFav">
        <div class="empty-state-icon">‚≠ê</div>
        <h3>No favorites yet</h3>
        <p>Star your frequently used shortcuts to add them to favorites!</p>
      </div>
    </div>

    <!-- Tab Content: Import -->
    <div class="tab-content" id="contentImport">
      <div class="import-section">
        <h2 class="mb-2">üì• Bulk Import Shortcuts</h2>
        <p class="form-help mb-3">
          Import multiple shortcuts at once using CSV or JSON format.
          Existing shortcuts with matching names will be updated.
        </p>

        <!-- Import Mode Selector -->
        <div class="import-mode-selector">
          <div class="mode-option active" data-mode="csv" onclick="selectImportMode('csv')">
            <div class="mode-option-title">üìä CSV Format</div>
            <div class="mode-option-desc">Comma-separated values</div>
          </div>
          <div class="mode-option" data-mode="json" onclick="selectImportMode('json')">
            <div class="mode-option-title">üîß JSON Format</div>
            <div class="mode-option-desc">JavaScript Object Notation</div>
          </div>
        </div>

        <!-- Import Options -->
        <div class="import-options">
          <div class="form-group mb-0">
            <label class="form-label">Default Application</label>
            <input type="text" id="defaultApplication" class="form-input" placeholder="e.g., General, Email, Code">
          </div>
          <div class="form-group mb-0">
            <label class="form-label">Default Language</label>
            <input type="text" id="defaultLanguage" class="form-input" placeholder="e.g., en, es, fr">
          </div>
        </div>

        <!-- Import Textarea -->
        <div class="form-group">
          <label class="form-label">Paste CSV or JSON content:</label>
          <textarea id="importText" class="import-textarea"
            placeholder="Paste your CSV or JSON data here..."></textarea>
          <div class="form-help" id="importMeta">
            CSV Format: Snippet Name,Content,Application,Description,Language,Tags
          </div>
        </div>

        <!-- Import Actions -->
        <div style="display: flex; gap: 8px;">
          <button id="btnImport" onclick="runImport()">
            üì• Import Shortcuts
          </button>
          <button class="btn-secondary" onclick="clearImportForm()">
            Clear
          </button>
          <button class="btn-secondary" onclick="showImportHelp()">
            ‚ùì Help
          </button>
        </div>

        <!-- Import Result -->
        <div id="importResult" class="import-result"></div>
      </div>
    </div>
  </div>

  <!-- Modal: Edit/Create Shortcut -->
  <div class="modal-overlay" id="modalOverlay" onclick="handleModalOverlayClick(event)">
    <div class="modal" onclick="event.stopPropagation()">
      <div class="modal-header">
        <h2 id="modalTitle">New Shortcut</h2>
        <button class="modal-close" onclick="showModal(false)">√ó</button>
      </div>
      <div class="modal-body">
        <form id="shortcutForm" onsubmit="event.preventDefault(); saveShortcut();">
          <div class="form-group">
            <label class="form-label required">Snippet Name</label>
            <input type="text" id="fKey" class="form-input" placeholder="e.g., addr, sig, meeting-template" required>
            <div class="form-help">
              Unique identifier for this shortcut (max 80 characters)
            </div>
          </div>

          <div class="form-group">
            <label class="form-label required">Content</label>
            <textarea id="fExpansion" class="form-textarea"
              placeholder="Enter the text that will expand when you use this shortcut..." required></textarea>
            <div class="form-help">
              The text that will be inserted (max 50,000 characters)
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">Application</label>
            <input type="text" id="fApplication" class="form-input" placeholder="e.g., Email, Slack, Google Docs">
            <div class="form-help">
              Where this shortcut is typically used
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">Description</label>
            <textarea id="fDescription" class="form-textarea" style="min-height: 80px;"
              placeholder="Optional description of what this shortcut does..."></textarea>
          </div>

          <div class="form-group">
            <label class="form-label">Language</label>
            <input type="text" id="fLanguage" class="form-input" placeholder="e.g., en, es, fr, code">
          </div>

          <div class="form-group mb-0">
            <label class="form-label">Tags</label>
            <input type="text" id="fTags" class="form-input" placeholder="e.g., work, personal, email, signature">
            <div class="form-help">
              Comma-separated tags for organization
            </div>
          </div>

          <div class="form-help error" id="formHelp"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button class="btn-danger" id="btnDelete" onclick="deleteSelectedShortcut()">
          üóëÔ∏è Delete
        </button>
        <button class="btn-secondary" onclick="showModal(false)">
          Cancel
        </button>
        <button id="btnSave" onclick="saveShortcut()">
          üíæ Save
        </button>
      </div>
    </div>
  </div>

  <!-- JavaScript -->
  <script>
    // ========================================================================
    // GLOBAL STATE
    // ========================================================================
    const state = {
      loaded: false,
      userEmail: '',
      shortcuts: [],
      favorites: [],
      version: '',
      tab: 'all',
      searchQuery: '',
      filterMode: 'all',
      languageFilter: 'all',        // 'all' | 'spanish' | 'english'
      typeFilter: 'all',             // 'all' | 'dates' | 'numbers' | 'greetings' | etc. (filters on description)
      searchDebounceTimer: null,    // Timer ID for debounced search
      editingKey: null,
      importMode: 'csv',
      // Progressive Loading (Snapshot)
      isFetching: false,
      hasMore: false,
      offset: 0,
      totalExpected: 0,
      snapshotToken: null,
      // Initialization guards
      isInitializing: false,
      bootstrapReceived: false
    };

    const CONFIG = {
      BATCH_SIZE: 1000,
      RENDER_CHUNK_SIZE: 50, // Items to render per frame
      DEBUG: true
    };

    // ========================================================================
    // UTILITY FUNCTIONS
    // ========================================================================

    /**
     * Shorthand for document.getElementById
     */
    function el(id) {
      return document.getElementById(id);
    }

    /**
     * Sets the status bar to busy/loading state
     * @param {string} message - Loading message to display
     */
    function setBusy(message) {
      const statusText = el('statusText');
      if (statusText) {
        statusText.textContent = message || 'Loading...';
        statusText.classList.add('loading');
      }
      // Disable action buttons during loading
      const btnRefresh = el('btnRefresh');
      const btnNew = el('btnNew');
      if (btnRefresh) btnRefresh.disabled = true;
      if (btnNew) btnNew.disabled = true;
    }

    /**
     * Sets the status bar to ready state
     * @param {string} message - Ready message to display
     */
    function setReady(message) {
      const statusText = el('statusText');
      if (statusText) {
        statusText.textContent = message || 'Ready';
        statusText.classList.remove('loading');
      }
      // Re-enable action buttons
      const btnRefresh = el('btnRefresh');
      const btnNew = el('btnNew');
      if (btnRefresh) btnRefresh.disabled = false;
      if (btnNew) btnNew.disabled = false;
    }

    /**
     * Shows a toast notification
     * @param {string} message - Toast message
     * @param {string} type - Toast type: 'good', 'warn', 'bad', or default
     */
    function toast(message, type) {
      const container = el('toastContainer');
      if (!container) {
        console.warn('[Toast] Container not found, logging instead:', message);
        return;
      }

      const toastEl = document.createElement('div');
      toastEl.className = 'toast ' + (type || '');

      const icons = {
        'good': '‚úÖ',
        'warn': '‚ö†Ô∏è',
        'bad': '‚ùå'
      };
      const icon = icons[type] || '‚ÑπÔ∏è';

      toastEl.innerHTML = `
        <span class="toast-icon">${icon}</span>
        <span class="toast-message">${message}</span>
      `;

      container.appendChild(toastEl);

      // Auto-remove after 4 seconds
      setTimeout(() => {
        toastEl.style.animation = 'toastSlideIn 0.3s ease-out reverse';
        setTimeout(() => toastEl.remove(), 300);
      }, 4000);
    }

    /**
     * Escapes HTML special characters to prevent XSS
     * @param {string} str - String to escape
     * @return {string} HTML-safe string
     */
    function escapeHtml(str) {
      if (str === null || str === undefined) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    /**
     * Safely encode a string for use in data attributes (Base64)
     * @param {string} str - String to encode
     * @return {string} Base64 encoded string
     */
    function safeEncode(str) {
      if (str === null || str === undefined) return '';
      try {
        return btoa(unescape(encodeURIComponent(String(str))));
      } catch (e) {
        console.error('[safeEncode] Failed to encode:', e);
        return '';
      }
    }

    /**
     * Safely decode a Base64 encoded string from data attributes
     * @param {string} encoded - Base64 encoded string
     * @return {string} Decoded string
     */
    function safeDecode(encoded) {
      if (!encoded) return '';
      try {
        return decodeURIComponent(escape(atob(encoded)));
      } catch (e) {
        console.error('[safeDecode] Failed to decode:', e);
        return '';
      }
    }

    /**
     * Find a shortcut by its ID
     * @param {string} id - Shortcut ID
     * @return {Object|null} Shortcut object or null
     */
    function findShortcutById(id) {
      return state.shortcuts.find(s => s.id === id) || null;
    }

    // ========================================================================
    // EVENT DELEGATION SYSTEM
    // Handles all grid clicks without inline onclick handlers
    // ========================================================================

    /**
     * Sets up event delegation on shortcut grids
     * Call this once during app initialization
     */
    function setupEventDelegation() {
      const shortcutsGrid = el('shortcutsGrid');
      const favoritesGrid = el('favoritesGrid');

      if (shortcutsGrid) {
        shortcutsGrid.addEventListener('click', handleGridClick);
      }
      if (favoritesGrid) {
        favoritesGrid.addEventListener('click', handleGridClick);
      }

      if (CONFIG.DEBUG) console.log('[EventDelegation] Set up on grids');
    }

    /**
     * Handles all click events on shortcut grids via delegation
     * @param {Event} event - Click event
     */
    function handleGridClick(event) {
      // Check for action buttons first (copy/favorite)
      const actionBtn = event.target.closest('[data-action]');
      if (actionBtn) {
        event.stopPropagation();
        event.preventDefault();

        const action = actionBtn.dataset.action;
        const id = actionBtn.dataset.id;
        const shortcut = findShortcutById(id);

        if (!shortcut) {
          console.error('[handleGridClick] Shortcut not found for ID:', id);
          toast('Shortcut not found.', 'bad');
          return;
        }

        if (action === 'copy') {
          doCopyToClipboard(shortcut, actionBtn);
        } else if (action === 'favorite') {
          doToggleFavorite(shortcut, actionBtn);
        }
        return;
      }

      // Check for card click (edit shortcut)
      const card = event.target.closest('.shortcut-card');
      if (card && card.dataset.id) {
        const id = card.dataset.id;
        const shortcut = findShortcutById(id);
        if (shortcut) {
          editShortcut(shortcut.key);
        } else {
          console.error('[handleGridClick] Shortcut not found for card ID:', id);
          toast('Shortcut not found.', 'bad');
        }
      }
    }

    /**
     * Handles copy to clipboard via event delegation
     * @param {Object} shortcut - Shortcut object
     * @param {HTMLElement} btn - Button element for visual feedback
     */
    function doCopyToClipboard(shortcut, btn) {
      const textToCopy = shortcut.expansion;
      const key = shortcut.key;

      // Visual feedback
      const originalHtml = btn.innerHTML;
      btn.innerHTML = '‚úÖ';

      // Try modern Clipboard API first
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(textToCopy)
          .then(() => {
            console.log(`[Copy] Copied "${key}" via Clipboard API`);
            toast(`Copied "${key}" to clipboard! üìã`, 'good');
            // Auto-favorite on copy
            google.script.run
              .withSuccessHandler((res) => {
                // Backend returns { status: 'added'|'removed', snippet: key }
                if (res && res.status === 'added') {
                  shortcut.favorite = true;
                  render();
                }
              })
              .withFailureHandler((err) => console.error('[Copy] Favorite failed:', err))
              .addToFavorites(key);
          })
          .catch((err) => {
            console.error('[Copy] Clipboard API failed:', err);
            fallbackCopy(textToCopy, key);
          })
          .finally(() => {
            setTimeout(() => { btn.innerHTML = originalHtml; }, 1000);
          });
      } else {
        // Fallback for older browsers
        fallbackCopy(textToCopy, key);
        setTimeout(() => { btn.innerHTML = originalHtml; }, 1000);
      }
    }

    /**
     * Fallback copy method using textarea
     */
    function fallbackCopy(text, key) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();
      try {
        document.execCommand('copy');
        toast(`Copied "${key}" to clipboard! üìã`, 'good');
      } catch (e) {
        toast('Copy failed. Please copy manually.', 'bad');
      }
      document.body.removeChild(textarea);
    }

    /**
     * Handles favorite toggle via event delegation
     * @param {Object} shortcut - Shortcut object
     * @param {HTMLElement} btn - Button element for visual feedback
     */
    function doToggleFavorite(shortcut, btn) {
      const key = shortcut.key;
      const currentFavorite = shortcut.favorite;

      console.log(`[Favorite] Toggle: ${key} -> ${!currentFavorite}`);

      btn.disabled = true;
      google.script.run
        .withSuccessHandler((res) => {
          btn.disabled = false;
          // Backend returns { status: 'added'|'removed'|'error', snippet: key, message?: string }
          if (res && res.status) {
            if (res.status === 'error') {
              // Handle error response from backend
              console.error('[Favorite] Backend error:', res.message);
              toast(res.message || 'Failed to update favorite.', 'bad');
            } else {
              const newFavoriteState = res.status === 'added';
              shortcut.favorite = newFavoriteState;
              render();
              toast(newFavoriteState ? `Added "${key}" to favorites! ‚≠ê` : `Removed "${key}" from favorites.`, 'good');
            }
          } else {
            toast('Failed to update favorite (invalid response).', 'bad');
          }
        })
        .withFailureHandler((err) => {
          btn.disabled = false;
          console.error('[Favorite] Error:', err);
          toast('Failed to update favorite.', 'bad');
        })
        .toggleFavorite(key);
    }

    // ========================================================================
    // UI LAYOUT SYNC (Fixed Header Height Management)
    // ========================================================================

    /**
     * Syncs the top bar height to CSS variable for proper content offset
     */
    function syncTopBarHeight() {
      const topBar = document.querySelector('.top-bar');
      if (topBar) {
        const height = topBar.offsetHeight;
        document.documentElement.style.setProperty('--topbar-h', height + 'px');
        if (CONFIG.DEBUG) console.log('[Layout] Top bar height:', height + 'px');
      }
    }

    /**
     * Sets up a resize observer to keep the top bar height in sync
     */
    function setupResizeObserver() {
      const topBar = document.querySelector('.top-bar');
      if (!topBar) return;

      // Use ResizeObserver if available, fallback to window resize
      if (typeof ResizeObserver !== 'undefined') {
        const observer = new ResizeObserver(() => {
          syncTopBarHeight();
        });
        observer.observe(topBar);
      } else {
        // Fallback for older browsers
        window.addEventListener('resize', syncTopBarHeight);
      }
    }

    // ========================================================================
    // INITIALIZATION & REFRESH
    // ========================================================================
    window.onload = function () {
      syncTopBarHeight();
      setupResizeObserver();
      // Initialize app and start data fetch
      initializeApp();
    };

    function initializeApp() {
      // Guard against duplicate initialization
      if (state.isInitializing || state.loaded) {
        console.warn('[initializeApp] Already initializing or loaded, skipping');
        return;
      }

      state.isInitializing = true;
      console.log('[initializeApp] Starting initialization...');
      setBusy('Initializing...');
      google.script.run
        .withSuccessHandler(handleBootstrapSuccess)
        .withFailureHandler(handleBootstrapFailure)
        .getAppBootstrapData();
    }

    function handleBootstrapSuccess(data) {
      console.log('[handleBootstrapSuccess] Called with data:', data ? 'object' : 'null');

      // Guard against duplicate callbacks
      if (state.bootstrapReceived) {
        console.warn('[handleBootstrapSuccess] Already received bootstrap, ignoring duplicate');
        return;
      }
      state.bootstrapReceived = true;

      if (!data || !data.ok) {
        console.error('[handleBootstrapSuccess] Data check failed', data);
        state.loaded = true;
        toast('Failed to load data.', 'bad');
        setReady('Load failed');
        return;
      }

      console.log('[handleBootstrapSuccess] Data OK, processing...');
      state.userEmail = data.userEmail || '';
      state.version = data.version || '';
      state.favorites = Array.isArray(data.favorites) ? data.favorites : [];

      console.log('[handleBootstrapSuccess] Setting email and version...');
      el('userEmail').textContent = state.userEmail || 'Not signed in';
      el('versionBadge').textContent = `v${state.version}`;

      try {
        console.log('[handleBootstrapSuccess] About to call refreshData...');
        refreshData(false);
        console.log('[handleBootstrapSuccess] refreshData returned normally');
      } catch (e) {
        console.error('[handleBootstrapSuccess] ERROR calling refreshData:', e);
      }
    }

    function refreshData(showToast) {
      console.log('[refreshData] Called, showToast=', showToast);

      if (state.isFetching) {
        console.warn('[refreshData] Fetch already in progress, ignoring.');
        return;
      }

      console.log('[refreshData] Starting snapshot fetch...');
      setBusy('Creating snapshot...');
      state.isFetching = true;
      state.shortcuts = [];
      state.offset = 0;
      state.hasMore = false;
      state.snapshotToken = null;

      if (showToast) toast('Refreshing data...', 'good');

      console.log('[refreshData] Calling beginShortcutsSnapshotHandler via google.script.run...');
      google.script.run
        .withSuccessHandler(function (res) {
          console.log('[refreshData] SUCCESS callback received!', res ? 'has response' : 'null');
          handleSnapshotCreated(res);
        })
        .withFailureHandler(function (err) {
          console.error('[refreshData] FAILURE callback received!', err);
          handleBootstrapFailure(err);
        })
        .beginShortcutsSnapshotHandler();

      console.log('[refreshData] google.script.run call initiated (async)');
    }

    function handleSnapshotCreated(res) {
      console.log('[handleSnapshotCreated] Called with:', res ? 'response object' : 'null/undefined');

      if (!res || !res.ok) {
        console.error('[handleSnapshotCreated] Failed', res);
        state.isFetching = false;
        toast('Failed to create data snapshot.', 'bad');
        setReady('Load failed');
        return;
      }

      console.log('[handleSnapshotCreated] Response OK, processing...');
      state.snapshotToken = res.snapshotToken;
      state.totalExpected = res.total || 0;

      const newItems = Array.isArray(res.shortcuts) ? res.shortcuts : [];
      console.log('[handleSnapshotCreated] Received', newItems.length, 'items');

      // Process initial batch with ID preservation
      state.shortcuts = newItems.map((item, i) => ({
        ...item,
        id: item.id || `shortcut-init-${i}`
      }));
      console.log('[handleSnapshotCreated] After processing:', state.shortcuts.length, 'items');

      state.offset = res.offset || newItems.length;
      state.hasMore = res.hasMore;

      if (CONFIG.DEBUG) console.log(`[Snapshot] Token: ${state.snapshotToken}, Total: ${state.totalExpected}, Initial: ${newItems.length}`);

      console.log('[handleSnapshotCreated] Calling updateStatusCount...');
      updateStatusCount();

      console.log('[handleSnapshotCreated] Calling renderImmediate...');
      renderImmediate();

      if (state.hasMore) {
        fetchNextBatch();
      } else {
        finishLoading();
      }
    }

    function fetchNextBatch() {
      if (!state.hasMore || !state.snapshotToken) {
        finishLoading();
        return;
      }

      setBusy(`Loading... (${state.shortcuts.length} / ${state.totalExpected})`);

      google.script.run
        .withSuccessHandler((res) => {
          if (!res || !res.ok) {
            // Check for snapshot expiration
            if (res && res.error === 'SNAPSHOT_EXPIRED') {
              console.warn('[fetchNextBatch] Snapshot expired. Restarting refresh...');
              state.isFetching = false; // Reset flag to allow refresh
              refreshData(true);
              return;
            }
            console.error('[fetchNextBatch] Batch failed', res);
            state.isFetching = false;
            toast('Error loading some shortcuts.', 'warn');
            return;
          }

          const newItems = Array.isArray(res.shortcuts) ? res.shortcuts : [];

          // DIAGNOSTIC: Track batch accumulation
          const beforeCount = state.shortcuts.length;
          const existingIds = new Set(state.shortcuts.map(s => s.id));
          let added = 0;
          let skippedDupe = 0;
          let skippedNoId = 0;

          for (let i = 0; i < newItems.length; i++) {
            const item = newItems[i];
            const id = item.id;

            if (!id) {
              skippedNoId++;
              continue;
            }

            if (existingIds.has(id)) {
              skippedDupe++;
              continue;
            }

            existingIds.add(id);
            state.shortcuts.push({ ...item, id: id });
            added++;
          }

          console.log(`[Batch] Received: ${newItems.length}, Added: ${added}, Skipped(dupe): ${skippedDupe}, Skipped(noId): ${skippedNoId}, Total now: ${state.shortcuts.length}`);

          state.offset = res.offset;
          state.hasMore = res.hasMore;

          updateStatusCount();
          renderImmediate();

          if (state.hasMore) {
            fetchNextBatch();
          } else {
            finishLoading();
          }
        })
        .withFailureHandler((err) => {
          console.error('[fetchNextBatch] Error:', err);
          state.isFetching = false;
          toast('Network error loading shortcuts.', 'bad');
        })
        .fetchShortcutsBatch(state.snapshotToken, state.offset, CONFIG.BATCH_SIZE);
    }

    function finishLoading() {
      state.isFetching = false;
      state.loaded = true;
      setReady(`${state.shortcuts.length} shortcuts loaded`);
      if (CONFIG.DEBUG) console.log(`[Load] Complete. Total: ${state.shortcuts.length}`);

      // Set up event delegation (only needs to be called once)
      setupEventDelegation();
      setupFilterDelegation();  // Set up filter chip and search delegation
      updateFilterCount();      // Initialize filter count display
    }

    function updateStatusCount() {
      const count = state.shortcuts.length;
      const total = state.totalExpected > count ? state.totalExpected : count;
      if (state.isFetching) {
        setBusy(`${count} / ${total} loaded...`);
      } else {
        setReady(`${count} shortcuts loaded`);
      }
    }

    // --- DATASET NORMALIZATION ---
    // Uses ID (not Snippet Name) for uniqueness to allow multiple shortcuts with same name
    function normalizeDataset(data) {
      const seen = new Set();
      const result = [];
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        // Use server-provided ID for uniqueness, fallback to generated ID
        const id = item.id || `shortcut-${i}-${Date.now()}`;
        if (!id) continue;
        if (seen.has(id)) continue;
        seen.add(id);
        result.push({ ...item, id: id });
      }
      return result;
    }

    function handleBootstrapFailure(err) {
      state.isFetching = false;
      state.loaded = true;
      setReady('Load failed');
      toast(err && err.message ? err.message : 'Failed to load data.', 'bad');
      render();
    }

    // ... (UI HELPERS remain)

    // ========================================================================
    // RENDERING (Chunked)
    // ========================================================================
    let renderDebounceTimer = null;
    let isRendering = false;
    let renderQueue = []; // For chunked rendering
    let renderAnimationFrameId = null;

    function render() {
      if (renderDebounceTimer) clearTimeout(renderDebounceTimer);
      renderDebounceTimer = setTimeout(() => {
        renderDebounceTimer = null;
        doRender();
      }, 50); // Increased debounce slightly to allow batch processing
    }

    function renderImmediate() {
      if (renderDebounceTimer) {
        clearTimeout(renderDebounceTimer);
        renderDebounceTimer = null;
      }
      doRender();
    }

    function doRender() {
      // Cancel any pending frame loop
      if (renderAnimationFrameId) {
        cancelAnimationFrame(renderAnimationFrameId);
        renderAnimationFrameId = null;
      }

      renderFavoritesGrid(); // Favorites are few, render instantly
      updateEmptyStates();

      // Start chunked render for main grid
      startChunkedRender();
    }

    function startChunkedRender() {
      const grid = el('shortcutsGrid');
      const filtered = getFilteredShortcuts();

      // Clear current content
      // OPTIMIZATION: If we implement a diff engine, that's better, but for now full re-render is safer for correctness.
      grid.innerHTML = '';

      if (filtered.length === 0) return;

      // Initialize queue
      renderQueue = filtered;
      let currentIndex = 0;

      function renderNextChunk() {
        const chunkEnd = Math.min(currentIndex + CONFIG.RENDER_CHUNK_SIZE, renderQueue.length);
        const fragment = document.createDocumentFragment();

        for (let i = currentIndex; i < chunkEnd; i++) {
          const item = renderQueue[i];
          const div = document.createElement('div');
          // Use innerHTML on a temp wrapper is faster than creating complex DOM structure manually
          // But here we insert the string into the grid directly? No, fragment needs nodes.
          // Let's use a helper to turn HTML string into node.
          div.innerHTML = createShortcutCard(item);
          // createShortcutCard returns the string for .shortcut-card. 
          // So div.firstElementChild is the card.
          if (div.firstElementChild) {
            fragment.appendChild(div.firstElementChild);
          }
        }

        grid.appendChild(fragment);
        currentIndex = chunkEnd;

        if (currentIndex < renderQueue.length) {
          renderAnimationFrameId = requestAnimationFrame(renderNextChunk);
        } else {
          // Finished rendering
          renderAnimationFrameId = null;
          renderQueue = [];
          setTimeout(syncTopBarHeight, 0); // Sync layout after full render
        }
      }

      renderNextChunk();
    }

    // ... (Rest of file: createShortcutCard, filters, event handlers remain unchanged)


    function renderFavoritesGrid() {
      const grid = el('favoritesGrid');
      const favorites = state.shortcuts.filter(s => s.favorite);

      if (favorites.length === 0) {
        grid.innerHTML = '';
        return;
      }

      grid.innerHTML = favorites.map(s => createShortcutCard(s)).join('');
    }

    function createShortcutCard(shortcut) {
      // Use data-id attributes instead of inline onclick handlers
      // This avoids issues with special characters breaking JavaScript strings
      const idAttr = escapeHtml(shortcut.id || '');
      const keyHtml = escapeHtml(shortcut.key);
      const expansionHtml = escapeHtml(shortcut.expansion);
      const applicationHtml = escapeHtml(shortcut.application || '');
      const languageHtml = escapeHtml(shortcut.language || '');
      const favoriteClass = shortcut.favorite ? 'active' : '';
      const favoriteTitle = escapeHtml(shortcut.favorite ? 'Remove from favorites' : 'Add to favorites');

      return `
        <div class="shortcut-card" data-id="${idAttr}">
          <div class="shortcut-card-header">
            <div class="shortcut-key">${keyHtml}</div>
            <div class="shortcut-actions">
              <button class="icon-btn favorite ${favoriteClass}" 
                      data-action="favorite" data-id="${idAttr}"
                      title="${favoriteTitle}">
                ${shortcut.favorite ? '‚òÖ' : '‚òÜ'}
              </button>
              <button class="icon-btn" 
                      data-action="copy" data-id="${idAttr}"
                      title="Copy content">
                üìã
              </button>
            </div>
          </div>
          <div class="shortcut-expansion">${expansionHtml}</div>
          <div class="shortcut-meta">
            ${applicationHtml ? `<span class="meta-tag app">${applicationHtml}</span>` : ''}
            ${languageHtml ? `<span class="meta-tag lang">${languageHtml}</span>` : ''}
          </div>
        </div>
      `;
    }


    function updateEmptyStates() {
      const allEmpty = el('emptyStateAll');
      const favEmpty = el('emptyStateFav');
      const filtered = getFilteredShortcuts();
      const favorites = state.shortcuts.filter(s => s.favorite);

      if (filtered.length === 0) {
        allEmpty.classList.remove('hidden');
      } else {
        allEmpty.classList.add('hidden');
      }

      if (favorites.length === 0) {
        favEmpty.classList.remove('hidden');
      } else {
        favEmpty.classList.add('hidden');
      }
    }

    function getFilteredShortcuts() {
      let filtered = state.shortcuts;

      // Apply type filter (filters on description field - category like dates, numbers, etc.)
      if (state.typeFilter !== 'all') {
        filtered = filtered.filter(s => {
          const desc = (s.description || '').toLowerCase();
          return desc === state.typeFilter || desc.includes(state.typeFilter);
        });
      }

      // Apply language filter
      if (state.languageFilter !== 'all') {
        filtered = filtered.filter(s => {
          const lang = (s.language || '').toLowerCase();
          // Support multiple language formats: 'spanish', 'es', 'espa√±ol', etc.
          if (state.languageFilter === 'spanish') {
            return lang === 'spanish' || lang === 'es' || lang === 'espa√±ol' || lang.includes('spanish');
          } else if (state.languageFilter === 'english') {
            return lang === 'english' || lang === 'en' || lang.includes('english');
          }
          return lang === state.languageFilter;
        });
      }

      // Apply search filter (scans key, expansion, tags, description)
      if (state.searchQuery) {
        const query = state.searchQuery.toLowerCase();
        filtered = filtered.filter(s =>
          s.key.toLowerCase().includes(query) ||
          s.expansion.toLowerCase().includes(query) ||
          (s.tags && s.tags.toLowerCase().includes(query)) ||
          (s.description && s.description.toLowerCase().includes(query)) ||
          (s.application && s.application.toLowerCase().includes(query)) ||
          (s.language && s.language.toLowerCase().includes(query))
        );
      }

      // Apply favorites filter
      if (state.filterMode === 'favorites') {
        filtered = filtered.filter(s => s.favorite);
      }

      return filtered;
    }

    // ========================================================================
    // TAB SWITCHING
    // ========================================================================
    function switchTab(name) {
      state.tab = name;

      el('tabAll').classList.toggle('active', name === 'all');
      el('tabFav').classList.toggle('active', name === 'fav');
      el('tabImport').classList.toggle('active', name === 'import');

      el('contentAll').classList.toggle('active', name === 'all');
      el('contentFav').classList.toggle('active', name === 'fav');
      el('contentImport').classList.toggle('active', name === 'import');

      if (name !== 'import') {
        render();
      }
      // Sync layout after tab switch
      setTimeout(syncTopBarHeight, 0);
    }

    // ========================================================================
    // SEARCH & FILTER (Enhanced with debouncing and event delegation)
    // ========================================================================

    /**
     * Debounced search handler (250ms delay)
     * Prevents UI jank during rapid typing
     */
    function handleSearch() {
      // Clear existing debounce timer
      if (state.searchDebounceTimer) {
        clearTimeout(state.searchDebounceTimer);
      }

      state.searchDebounceTimer = setTimeout(() => {
        state.searchQuery = el('searchInput').value;
        render();
        updateFilterCount();
      }, 250);
    }

    /**
     * Clear search input and reset filter
     */
    function clearSearch() {
      el('searchInput').value = '';
      state.searchQuery = '';
      render();
      updateFilterCount();
    }

    /**
     * Clear all filters and reset to default state
     */
    function clearAllFilters() {
      // Reset state
      state.searchQuery = '';
      state.filterMode = 'all';
      state.languageFilter = 'all';
      state.typeFilter = 'all';

      // Reset UI
      el('searchInput').value = '';

      // Reset chip active states
      document.querySelectorAll('#categoryFilters .chip').forEach(c => {
        c.classList.toggle('active', c.dataset.filter === 'all');
      });
      document.querySelectorAll('#languageFilters .chip').forEach(c => {
        c.classList.toggle('active', c.dataset.filter === 'all');
      });
      document.querySelectorAll('#typeFilters .chip').forEach(c => {
        c.classList.toggle('active', c.dataset.filter === 'all');
      });

      render();
      updateFilterCount();
    }

    /**
     * Updates active state for chips in a container
     */
    function updateChipActiveState(container, activeChip) {
      container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
      activeChip.classList.add('active');
    }

    /**
     * Updates the filter result count banner
     */
    function updateFilterCount() {
      const filtered = getFilteredShortcuts();
      const banner = el('filterResultCount');
      const countEl = el('filteredCount');
      const totalEl = el('totalCount');

      if (!banner) return;

      // Show banner only when filters are active
      const hasActiveFilter = state.searchQuery ||
        state.filterMode !== 'all' ||
        state.languageFilter !== 'all' ||
        state.typeFilter !== 'all';

      if (hasActiveFilter) {
        banner.style.display = 'flex';
        // Show capped count if over RENDER_CHUNK_SIZE
        const displayCount = Math.min(filtered.length, CONFIG.RENDER_CHUNK_SIZE);
        countEl.textContent = displayCount;
        totalEl.textContent = filtered.length;
        // Update banner text based on whether results are capped
        if (filtered.length > CONFIG.RENDER_CHUNK_SIZE) {
          countEl.parentElement.innerHTML = `Showing <span class="count" id="filteredCount">${displayCount}</span> of <span id="totalCount">${filtered.length}</span> results`;
        }
      } else {
        banner.style.display = 'none';
      }
    }

    /**
     * Sets up event delegation for filter chips and search
     * Call once during initialization
     */
    function setupFilterDelegation() {
      // Search input event listener
      const searchInput = el('searchInput');
      if (searchInput) {
        searchInput.addEventListener('input', handleSearch);
      }

      // Clear search button
      const btnClearSearch = el('btnClearSearch');
      if (btnClearSearch) {
        btnClearSearch.addEventListener('click', clearSearch);
      }

      // Clear all filters button
      const btnClearAll = el('btnClearAllFilters');
      if (btnClearAll) {
        btnClearAll.addEventListener('click', clearAllFilters);
      }

      // Category filters (event delegation)
      const categoryFilters = el('categoryFilters');
      if (categoryFilters) {
        categoryFilters.addEventListener('click', (e) => {
          const chip = e.target.closest('[data-filter-type="category"]');
          if (chip) {
            state.filterMode = chip.dataset.filter;
            updateChipActiveState(categoryFilters, chip);
            render();
            updateFilterCount();
          }
        });
      }

      // Language filters (event delegation)
      const languageFilters = el('languageFilters');
      if (languageFilters) {
        languageFilters.addEventListener('click', (e) => {
          const chip = e.target.closest('[data-filter-type="language"]');
          if (chip) {
            state.languageFilter = chip.dataset.filter;
            updateChipActiveState(languageFilters, chip);
            render();
            updateFilterCount();
          }
        });
      }

      // Type filters (event delegation) - filters on description field
      const typeFilters = el('typeFilters');
      if (typeFilters) {
        typeFilters.addEventListener('click', (e) => {
          const chip = e.target.closest('[data-filter-type="type"]');
          if (chip) {
            state.typeFilter = chip.dataset.filter;
            updateChipActiveState(typeFilters, chip);
            render();
            updateFilterCount();
          }
        });
      }

      if (CONFIG.DEBUG) console.log('[FilterDelegation] Set up on filter chips and search');
    }

    // Legacy function for backward compatibility (if any inline onclick remain)
    function handleFilterClick(chip, filter) {
      state.filterMode = filter;

      document.querySelectorAll('.filter-chips .chip').forEach(c => {
        c.classList.remove('active');
      });
      chip.classList.add('active');

      render();
      updateFilterCount();
    }

    // ========================================================================
    // MODAL MANAGEMENT
    // ========================================================================
    function showModal(show) {
      el('modalOverlay').classList.toggle('active', show);
      if (!show) {
        clearForm();
      }
    }

    function handleModalOverlayClick(event) {
      if (event.target === el('modalOverlay')) {
        showModal(false);
      }
    }

    function openNewShortcutModal() {
      state.editingKey = null;
      el('modalTitle').textContent = 'New Shortcut';
      el('btnDelete').style.display = 'none';
      clearForm();
      showModal(true);
      el('fKey').focus();
    }

    function editShortcut(key) {
      const shortcut = state.shortcuts.find(s => s.key === key);
      if (!shortcut) {
        toast('Shortcut not found.', 'bad');
        return;
      }

      state.editingKey = key;
      el('modalTitle').textContent = 'Edit Shortcut';
      el('btnDelete').style.display = 'inline-flex';

      el('fKey').value = shortcut.key;
      el('fExpansion').value = shortcut.expansion;
      el('fApplication').value = shortcut.application || '';
      el('fDescription').value = shortcut.description || '';
      el('fLanguage').value = shortcut.language || '';
      el('fTags').value = shortcut.tags || '';
      el('formHelp').textContent = '';

      showModal(true);
      el('fKey').focus();
    }

    function clearForm() {
      el('fKey').value = '';
      el('fExpansion').value = '';
      el('fApplication').value = '';
      el('fDescription').value = '';
      el('fLanguage').value = '';
      el('fTags').value = '';
      el('formHelp').textContent = '';
    }

    // ========================================================================
    // SHORTCUT CRUD
    // ========================================================================
    function saveShortcut() {
      const payload = {
        key: el('fKey').value.trim(),
        expansion: el('fExpansion').value,
        application: el('fApplication').value.trim(),
        description: el('fDescription').value.trim(),
        language: el('fLanguage').value.trim(),
        tags: el('fTags').value.trim()
      };

      // Client-side validation
      const v = validatePayload(payload);
      if (!v.ok) {
        el('formHelp').textContent = v.message;
        toast(v.message, 'warn');
        return;
      }

      el('btnSave').disabled = true;
      el('btnDelete').disabled = true;
      el('formHelp').textContent = 'Saving‚Ä¶';

      google.script.run
        .withSuccessHandler((res) => {
          el('btnSave').disabled = false;
          el('btnDelete').disabled = false;

          if (!res || !res.ok) {
            const msg = res && res.message ? res.message : 'Save failed.';
            el('formHelp').textContent = msg;
            toast(msg, 'bad');
            return;
          }

          toast(res.message || 'Saved.', 'good');
          showModal(false);
          refreshData(true);
        })
        .withFailureHandler((err) => {
          el('btnSave').disabled = false;
          el('btnDelete').disabled = false;
          const msg = err && err.message ? err.message : 'Save failed.';
          el('formHelp').textContent = msg;
          toast(msg, 'bad');
        })
        .upsertShortcut(payload);
    }

    function deleteSelectedShortcut() {
      const key = String(el('fKey').value || '').trim();
      if (!key) {
        toast('Missing Snippet Name.', 'warn');
        return;
      }
      const ok = confirm(`Delete "${key}"?`);
      if (!ok) return;

      el('btnSave').disabled = true;
      el('btnDelete').disabled = true;
      el('formHelp').textContent = 'Deleting‚Ä¶';

      google.script.run
        .withSuccessHandler((res) => {
          el('btnSave').disabled = false;
          el('btnDelete').disabled = false;

          if (!res || !res.ok) {
            toast(res && res.message ? res.message : 'Delete failed.', 'bad');
            el('formHelp').textContent = res && res.message ? res.message : 'Delete failed.';
            return;
          }

          toast(res.message || 'Deleted.', 'good');
          showModal(false);
          refreshData(true);
        })
        .withFailureHandler((err) => {
          el('btnSave').disabled = false;
          el('btnDelete').disabled = false;
          toast(err && err.message ? err.message : 'Delete failed.', 'bad');
          el('formHelp').textContent = err && err.message ? err.message : 'Delete failed.';
        })
        .deleteShortcut(key);
    }

    function validatePayload(payload) {
      if (!payload.key) return { ok: false, message: 'Snippet Name is required.' };
      if (payload.key.length > 80) return { ok: false, message: 'Snippet Name too long (max 80).' };
      if (!payload.expansion) return { ok: false, message: 'Content is required.' };
      if (payload.expansion.length > 50000) return { ok: false, message: 'Content too long (max 50,000).' };
      return { ok: true };
    }

    // ========================================================================
    // FAVORITES - FIXED WITH EVENT HANDLERS
    // ========================================================================

    /**
     * üî• FIX #1: Star button handler with event.stopPropagation()
     * This prevents the card click event from firing when clicking the star
     *
     * FIX #2: Properly handle state update and render to prevent duplication.
     * - Update local state immediately for instant feedback
     * - Render immediately to show the change
     * - Then do a background refresh (without re-rendering until complete)
     */
    let favoriteRefreshPending = false;

    function toggleFavoriteHandler(event, key, shouldFavorite) {
      // CRITICAL: Stop event from bubbling to card click handler
      event.stopPropagation();
      event.preventDefault();

      if (!key) {
        toast('Invalid shortcut key.', 'bad');
        return;
      }

      // Disable button to prevent double-clicks
      const btn = event.currentTarget;
      const originalHtml = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = '‚è≥';

      console.log(`[toggleFavoriteHandler] Toggle: ${key} -> ${shouldFavorite}`);

      google.script.run
        .withSuccessHandler((res) => {
          console.log('[toggleFavoriteHandler] Result:', res);
          btn.disabled = false;

          if (!res || !res.status) {
            btn.innerHTML = originalHtml;
            toast('Favorite update failed (invalid response).', 'bad');
            return;
          }

          const isAdded = res.status === 'added';

          // Update local state immediately for instant UI feedback
          const shortcut = state.shortcuts.find(s => s.key === key);
          if (shortcut) {
            shortcut.favorite = isAdded;
          }

          // Update button immediately
          btn.innerHTML = isAdded ? '‚òÖ' : '‚òÜ';
          btn.classList.toggle('active', isAdded);
          btn.title = isAdded ? 'Remove from favorites' : 'Add to favorites';

          toast(isAdded ? 'Added to favorites.' : 'Removed from favorites.', 'good');

          // Render immediately to reflect the change
          renderImmediate();

          // Background sync to ensure consistency (debounced to avoid multiple refreshes)
          if (!favoriteRefreshPending) {
            favoriteRefreshPending = true;
            setTimeout(() => {
              favoriteRefreshPending = false;
              refreshDataSilent();
            }, 500);
          }
        })
        .withFailureHandler((err) => {
          console.error('[toggleFavoriteHandler] Error:', err);
          btn.disabled = false;
          btn.innerHTML = originalHtml;
          toast(err && err.message ? err.message : 'Favorite update failed.', 'bad');
        })
        .toggleFavorite(key);
    }

    // ========================================================================
    // COPY TO CLIPBOARD - FIXED WITH PROPER HANDLER
    // ========================================================================

    /**
     * üî• FIX #2: Copy to clipboard with event.stopPropagation() and proper clipboard API
     * Uses modern Clipboard API with fallback to execCommand
     */
    function copyToClipboardHandler(event, key) {
      // CRITICAL: Stop event from bubbling to card click handler
      event.stopPropagation();
      event.preventDefault();

      const shortcut = state.shortcuts.find(s => s.key === key);
      if (!shortcut) {
        toast('Shortcut not found.', 'bad');
        return;
      }

      const textToCopy = shortcut.expansion;

      // Visual feedback
      const btn = event.currentTarget;
      const originalHtml = btn.innerHTML;
      btn.innerHTML = '‚úÖ';

      // Try modern Clipboard API first (requires HTTPS or localhost)
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(textToCopy)
          .then(() => {
            console.log(`Copied "${key}" to clipboard via Clipboard API`);
            toast(`Copied "${key}" to clipboard! üìã`, 'good');

            // Log the copy action AND auto-favorite
            google.script.run
              .withSuccessHandler((res) => {
                console.log('[copyToClipboard] Favorite result:', res);
                if (res && res.ok && res.favorite) {
                  // Update local state if it became a favorite
                  const s = state.shortcuts.find(item => item.key === key);
                  if (s && !s.favorite) {
                    s.favorite = true;
                    renderImmediate();
                  }
                }
              })
              .withFailureHandler((err) => console.warn('[copyToClipboard] Log failed:', err))
              .handleClipboardFavorite(key);

            // Reset button icon
            setTimeout(() => { btn.innerHTML = originalHtml; }, 1000);
          })
          .catch((err) => {
            console.warn('Clipboard API failed, trying fallback:', err);
            copyToClipboardFallback(textToCopy, key, btn, originalHtml);
          });
      } else {
        // Fallback for older browsers
        console.log('Clipboard API not available, using fallback');
        copyToClipboardFallback(textToCopy, key, btn, originalHtml);
      }
    }

    /**
     * Fallback clipboard method using textarea + execCommand
     */
    function copyToClipboardFallback(text, key, btn, originalHtml) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.top = '0';
      textarea.style.left = '0';
      textarea.style.opacity = '0';
      textarea.style.pointerEvents = 'none';
      document.body.appendChild(textarea);

      try {
        textarea.select();
        textarea.setSelectionRange(0, 99999); // For mobile devices

        const successful = document.execCommand('copy');

        if (successful) {
          console.log(`Copied "${key}" to clipboard via execCommand`);
          toast(`Copied "${key}" to clipboard! üìã`, 'good');

          // Log the copy action AND auto-favorite
          google.script.run
            .withSuccessHandler((res) => {
              console.log('[copyToClipboardFallback] Favorite result:', res);
              if (res && res.ok && res.favorite) {
                const s = state.shortcuts.find(item => item.key === key);
                if (s && !s.favorite) {
                  s.favorite = true;
                  renderImmediate();
                }
              }
            })
            .withFailureHandler((err) => console.warn('[copyToClipboardFallback] Log failed:', err))
            .handleClipboardFavorite(key);
        } else {
          throw new Error('execCommand failed');
        }
      } catch (err) {
        console.error('Copy failed:', err);
        toast('Failed to copy. Please try manual selection.', 'bad');
      } finally {
        document.body.removeChild(textarea);
        setTimeout(() => { btn.innerHTML = originalHtml; }, 1000);
      }
    }

    // NOTE: The main refreshData function is defined earlier in the file (line ~1312) with proper snapshot handling

    /**
     * Silent background refresh - updates data without UI feedback.
     * Uses progressive loading but suppresses toasts.
     */
    function refreshDataSilent() {
      if (state.isFetching) return;

      console.log('[refreshDataSilent] Starting background sync...');
      state.isFetching = true;
      // Note: For silent refresh, we might want to keep existing data visible until new data arrives
      // But for simplicity and correctness with the new architecture, we'll reset and fetch.
      // Ideally, we'd fetch into a temp buffer and swap, but let's stick to the main pattern.
      state.shortcuts = [];
      state.offset = 0;

      google.script.run
        .withSuccessHandler(handleBootstrapSuccess)
        .withFailureHandler((err) => {
          console.warn('[refreshDataSilent] Background sync failed:', err);
          state.isFetching = false;
        })
        .getAppBootstrapData();
    }

    // ========================================================================
    // IMPORT
    // ========================================================================
    function selectImportMode(mode) {
      state.importMode = mode;

      document.querySelectorAll('.mode-option').forEach(opt => {
        opt.classList.remove('active');
      });
      document.querySelector(`.mode-option[data-mode="${mode}"]`).classList.add('active');

      updateImportMeta();
    }

    function updateImportMeta() {
      const metaEl = el('importMeta');
      if (state.importMode === 'csv') {
        metaEl.textContent = 'CSV Format: Snippet Name,Content,Application,Description,Language,Tags';
      } else {
        metaEl.textContent = 'JSON Format: Array of objects with keys: key, expansion, application, description, language, tags';
      }
    }

    function clearImportForm() {
      el('importText').value = '';
      el('defaultApplication').value = '';
      el('defaultLanguage').value = '';
      el('importResult').style.display = 'none';
      el('importResult').textContent = '';
    }

    function showImportHelp() {
      const csvExample = `Snippet Name,Content,Application,Description,Language,Tags
addr,"123 Main St\nCity, State 12345",Email,My address,en,contact
sig,"Best regards,\nJohn Doe",Email,Email signature,en,signature`;

      const jsonExample = `[
  {
    "key": "addr",
    "expansion": "123 Main St\\nCity, State 12345",
    "application": "Email",
    "description": "My address",
    "language": "en",
    "tags": "contact"
  },
  {
    "key": "sig",
    "expansion": "Best regards,\\nJohn Doe",
    "application": "Email",
    "description": "Email signature",
    "language": "en",
    "tags": "signature"
  }
]`;

      const example = state.importMode === 'csv' ? csvExample : jsonExample;
      alert(`Import Help\n\n${state.importMode.toUpperCase()} Example:\n\n${example}\n\nNotes:\n- First column/key must be the snippet name\n- Required fields: Snippet Name, Content\n- Existing shortcuts will be updated\n- Default values will be used for missing optional fields`);
    }

    function runImport() {
      const mode = state.importMode;
      const text = el('importText').value;
      const defaultApplication = el('defaultApplication').value;
      const defaultLanguage = el('defaultLanguage').value;

      if (!String(text || '').trim()) {
        toast('Paste CSV or JSON content first.', 'warn');
        return;
      }

      el('btnImport').disabled = true;
      el('importMeta').textContent = 'Importing‚Ä¶';
      el('importResult').textContent = '';
      el('importResult').style.display = 'none';

      google.script.run
        .withSuccessHandler((res) => {
          el('btnImport').disabled = false;
          el('importMeta').textContent = 'Paste CSV or JSON';

          if (!res || !res.ok) {
            const msg = res && res.message ? res.message : 'Import failed.';
            toast(msg, 'bad');
            el('importResult').textContent = msg;
            el('importResult').className = 'import-result error';
            return;
          }

          toast(res.message || 'Import complete.', 'good');

          const detail = [];
          detail.push(res.message || 'Import complete.');
          if (Array.isArray(res.errors) && res.errors.length) {
            detail.push('Errors:');
            for (const e of res.errors.slice(0, 50)) {
              detail.push(`Row ${e.index}: ${e.key} ‚Äî ${e.message}`);
            }
            if (res.errors.length > 50) {
              detail.push(`... and ${res.errors.length - 50} more errors.`);
            }
          }
          el('importResult').textContent = detail.join('\n');
          el('importResult').className = 'import-result success';

          refreshData(false);
        })
        .withFailureHandler((err) => {
          el('btnImport').disabled = false;
          el('importMeta').textContent = 'Paste CSV or JSON';
          const msg = err && err.message ? err.message : 'Import failed.';
          toast(msg, 'bad');
          el('importResult').textContent = msg;
          el('importResult').className = 'import-result error';
        })
        .bulkImport({ mode, text, defaultApplication, defaultLanguage });
    }
  </script>
</body>

</html>